env HOME=$WORK/home

benchinit -r -benchtime=10x .
stdout '^BenchmarkInit'
! stdout ' -[0-9].*/op' # initialising "time" again can lead to negative durations

-- go.mod --
module test.tld/foo
-- import.go --
package foo

import (
	// these can cause issues.
	_ "runtime"
	_ "testing"
	"os/signal"
	"flag"

	// these surprisingly don't. perhaps we need more code below.
	_ "unsafe"
	"os"
	"sync"
	_ "sync/atomic"
	_ "errors"
	_ "io"
	_ "runtime/debug"
	_ "runtime/pprof"
	_ "runtime/trace"
	_ "time"
	_ "syscall"
	_ "fmt"

	_ "test.tld/foo/imported"
)

var (
	fooOnce sync.Once
	foo     bool

	sign = make(chan os.Signal, 1)

	flagSet flag.FlagSet

	numPool = sync.Pool{
		New: func() interface{} { return new(int) },
	}
)

func init() {
	fooOnce.Do(func() { foo = true })

	signal.Notify(sign, os.Interrupt)

	var b bool
	// We must zero FlagSet's map of defined flags to avoid "flag redefined"
	// panics.
	flagSet.BoolVar(&b, "i", false, "")

	// Must be *int; otherwise the pool global has been broken.
	_ = numPool.Get().(*int)
}
-- imported/imported.go --
package imported

import "flag"

var flagSet flag.FlagSet

type withFlagset struct {
	withFlagset2
}

type withFlagset2 struct {
	Flag flag.FlagSet
}

var flagSet2 withFlagset

func init() {
	var b bool
	// Check that we zero these in dependencies too, when in recursive mode.
	flagSet.BoolVar(&b, "i", false, "")

	// Check that we zero the flagset's field when nested, too.
	flagSet2.Flag.BoolVar(&b, "i2", false, "")
}
